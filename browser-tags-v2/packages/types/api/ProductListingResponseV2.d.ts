/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type SortingOrder = "asc" | "desc";
/**
 * Title of the group, where a group consists of all the filters that share an ID.
 */
export type GroupTitle = string | null;
/**
 * Whether the filter group should be expanded by default or not.
 */
export type GroupExpanded = boolean | null;
/**
 * Type of filter.
 */
export type Type = "radio" | "checkbox" | "checkbox-grid" | "checkbox-color";
/**
 * Selectable values
 */
export type Values = (
  | ("true" | "false")
  | number
  | number
  | string
    | [string, string]
    | [string, number]
    | [number, string]
    | [number, number]
  )[];
/**
 * Counts for values
 */
export type Counts = number[];
/**
 * Names for values. This is what should be displayed along with the UI item for the value.
 */
export type Names = string[] | null;
/**
 * Swatches for values. This is what should be displayed along with the UI item for the value.The values in this list are meant to be used as [CSS background](https://developer.mozilla.org/en-US/docs/Web/CSS/background) values.
 */
export type Swatches = (string | null)[] | null;
/**
 * Title of the group, where a group consists of all the filters that share an ID.
 */
export type GroupTitle1 = string | null;
/**
 * Whether the filter group should be expanded by default or not.
 */
export type GroupExpanded1 = boolean | null;
export type Type1 = "checkbox-hierarchical";
/**
 * Selectable hierarchical values
 */
export type Values1 = string[][];
/**
 * Counts for values
 */
export type Counts1 = number[];
/**
 * Names for hierarchical values, this is what you should display in the UI (not values)
 */
export type Names1 = string[] | null;
export type ECategoryType = "TAG" | "CATEGORY" | "TENANT_CATEGORY" | "TENANT_SECONDARY_CATEGORY" | "CAMPAIGN" | "BRAND";

export interface ProductListingResponseV2 {
  /**
   * The products to be shown on the product listing page.
   */
  displays: {
    [k: string]: unknown;
  }[];
  /**
   * Total number of results for this query. Not necessarily exact.
   */
  n_hits: number;
  /**
   * Available methods for sorting the response. Any element from this list can be sent as `sort` in subsequent requests.
   */
  sorts?: SortModel[];
  /**
   * Available filters that can be used for filtering in the subsequent request.
   */
  filters?: SearchFilter[];
  product_listing_request_id: string;
  /**
   * Cursor that can be used in the next request to get subsequent results when using cursor based pagination. If this is not set, there are no more results.
   */
  cursor?: string;
  /**
   * Deprecated, do not use.
   */
  page?: number;
  /**
   * Maps product ID to grouping ID. Only returned if `return_grouping_ids` is True.
   */
  grouping_ids?: {
    [k: string]: string;
  };
  /**
   * Breadcrumb for the current page. Ordered from less to more specific, where the last element is the current page.
   */
  breadcrumb?: BaseCategoryDisplay[];
  /**
   * List of pages that can be used as quick links. Will return child pages if they exist, otherwise sibling pages.
   */
  quick_links?: BaseCategoryDisplay[];
  metadata?: PLPMetadata;
}
export interface SortModel {
  /**
   * The field to sort by.
   */
  field: string;
  /**
   * The order to sort by.
   */
  order: SortingOrder;
  meta?: SortMeta;
}
/**
 * Metadata about the sort that can be used for rendering.
 */
export interface SortMeta {
  title: string;
  /**
   * Selectable values
   */
  values?: SortingOrder[];
  /**
   * Names for orders (this is what you should display in the UI, not values)
   */
  names?: string[];
}
export interface SearchFilter {
  /**
   * The field to filter by.
   */
  field: string;
  /**
   * The operation used for filtering. The filtering should be read as `field op data`, for example `brand in ["Nike", "Adidas"]`.
   */
  op: "eq" | "neq" | "in" | "nin" | "leq" | "geq" | "inrange";
  /**
   * Data for the filter.
   */
  data?:
    | ("true" | "false")
    | number
    | number
    | string
    | [string, string]
    | [string, number]
    | [number, string]
    | [number, number]
  | (
        | ("true" | "false")
        | number
        | number
        | string
    | [string, string]
    | [string, number]
    | [number, string]
    | [number, number]
  )[]
    | string[][];
  /**
   * Metadata about the filter that can be used for rendering. For example, this could contain the possible values to filter by and their counts in the results.
   */
  meta?: RangeFilterMeta | ValuesFilterMeta | HierarchicalValuesFilterMeta;
  /**
   * ID of the filter. If multiple filters share the same ID, they should be grouped together in the UI.
   */
  id?: string;
}
export interface RangeFilterMeta {
  /**
   * Title of the group, where a group consists of all the filters that share an ID.
   */
  group_title?: string;
  /**
   * Whether the filter group should be expanded by default or not.
   */
  group_expanded?: boolean;
  type: "range";
  /**
   * The minimum value that can be selected in the range.
   */
  min: number;
  /**
   * The maximum value that can be selected in the range.
   */
  max: number;
  /**
   * The unit of the range values.
   */
  unit?: string;
  /**
   * The currency of the range values.
   */
  currency?: string;
}
export interface ValuesFilterMeta {
  group_title?: GroupTitle;
  group_expanded?: GroupExpanded;
  type: Type;
  values: Values;
  counts: Counts;
  names?: Names;
  swatches?: Swatches;
}
export interface HierarchicalValuesFilterMeta {
  group_title?: GroupTitle1;
  group_expanded?: GroupExpanded1;
  type: Type1;
  values: Values1;
  counts: Counts1;
  names?: Names1;
}
export interface BaseCategoryDisplay {
  /**
   * Unique identifier of the category.
   */
  category_id: string;
  /**
   * The title of the category
   */
  title: string;
  /**
   * The full URL to the category page
   */
  page_url?: string;
  /**
   * Optionally a unique query ID for the category
   */
  query_id?: string;
  /**
   * Optionally a unique URI for the category, for example men/shoes
   */
  uri?: string;
  /**
   * The type of category, for example CAMPAIGN, TAG, or CATEGORY
   */
  category_type?: ECategoryType & string;
}
/**
 * Metadata about the PLP requested, for example Collection/Category title, description, etc.
 */
export interface PLPMetadata {
  title: string;
  description?: string;
  /**
   * Whether to replace the page meta tags, e.g., title and description, with the ones from the collection.
   */
  replace_meta_tags?: boolean;
  [k: string]: unknown;
}
